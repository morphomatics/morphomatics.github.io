{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Morphomatics - Geometric morphometrics in non-Euclidean shape spaces Morphomatics is an open-source Python library for (statistical) shape analysis developed within the geometric data analysis and processing research group at Zuse Institute Berlin. It contains prototype implementations of intrinsic manifold-based methods that are highly consistent and avoid the influence of unwanted effects such as bias due to arbitrary choices of coordinates. The source code is freely available on GitHub. If you are using Morphomatics to derive results for a publication, we politely ask you to aknowledge Morphomatics in your manuscript and to cite each of the publications (listed below) that are relevant for your use. Of course, if you want, we will also list a reference to your work here. Riemannian shape spaces We provide a novel Riemannian framework for shape analysis based on differential coordinates that naturally belong to Lie groups and effectively describe local changes in shape. Performing intrinsic calculus on this representation allows for fast computations while, at the same time, accounts for the nonlinearity in shape variation. The rich structure of the derived shape space yields highly discriminative shape descriptors providing a compact representation that is amenable to learning algorithms. References: Christoph von Tycowicz, Felix Ambellan, Anirban Mukhopadhyay, and Stefan Zachow: An Efficient Riemannian Statistical Shape Model using Differential Coordinates. Medical Image Analysis, Volume 43, January 2018. Felix Ambellan, Stefan Zachow, and Christoph von Tycowicz: A Surface-Theoretic Approach for Statistical Shape Modeling. Proc. Medical Image Computing and Computer Assisted Intervention (MICCAI), Lecture Notes in Computer Science, 2019. Manifold-valued regression References: Martin Hanik, Hans-Christian Hege, Anja Hennemuth, Christoph von Tycowicz: Nonlinear Regression on Manifolds for Shape Analysis using Intrinsic B\u00e9zier Splines. Proc. Medical Image Computing and Computer Assisted Intervention (MICCAI), 2020. Citations Contributors Christoph von Tycowicz Felix Ambellan Martin Hanik Install buckle up!","title":"Home"},{"location":"#morphomatics-geometric-morphometrics-in-non-euclidean-shape-spaces","text":"Morphomatics is an open-source Python library for (statistical) shape analysis developed within the geometric data analysis and processing research group at Zuse Institute Berlin. It contains prototype implementations of intrinsic manifold-based methods that are highly consistent and avoid the influence of unwanted effects such as bias due to arbitrary choices of coordinates. The source code is freely available on GitHub. If you are using Morphomatics to derive results for a publication, we politely ask you to aknowledge Morphomatics in your manuscript and to cite each of the publications (listed below) that are relevant for your use. Of course, if you want, we will also list a reference to your work here.","title":"Morphomatics - Geometric morphometrics in non-Euclidean shape spaces"},{"location":"#riemannian-shape-spaces","text":"We provide a novel Riemannian framework for shape analysis based on differential coordinates that naturally belong to Lie groups and effectively describe local changes in shape. Performing intrinsic calculus on this representation allows for fast computations while, at the same time, accounts for the nonlinearity in shape variation. The rich structure of the derived shape space yields highly discriminative shape descriptors providing a compact representation that is amenable to learning algorithms. References: Christoph von Tycowicz, Felix Ambellan, Anirban Mukhopadhyay, and Stefan Zachow: An Efficient Riemannian Statistical Shape Model using Differential Coordinates. Medical Image Analysis, Volume 43, January 2018. Felix Ambellan, Stefan Zachow, and Christoph von Tycowicz: A Surface-Theoretic Approach for Statistical Shape Modeling. Proc. Medical Image Computing and Computer Assisted Intervention (MICCAI), Lecture Notes in Computer Science, 2019.","title":"Riemannian shape spaces"},{"location":"#manifold-valued-regression","text":"References: Martin Hanik, Hans-Christian Hege, Anja Hennemuth, Christoph von Tycowicz: Nonlinear Regression on Manifolds for Shape Analysis using Intrinsic B\u00e9zier Splines. Proc. Medical Image Computing and Computer Assisted Intervention (MICCAI), 2020.","title":"Manifold-valued regression"},{"location":"#citations","text":"","title":"Citations"},{"location":"#contributors","text":"Christoph von Tycowicz Felix Ambellan Martin Hanik","title":"Contributors"},{"location":"#install","text":"buckle up!","title":"Install"},{"location":"tutorial_regression/","text":"Manifold-valued regression Regression analysis is a reliable statistical approach to estimate the relationship between observed variables, e.g. shapes and their co-varying parameters. For geometric data we again required intrinsic approaches that account for and fully leverage the geometry of the data space. The most widely used is to approximate the observed temporal shape data by geodesics, i.e. generalized straight lines. Geodesic models are attractive as they feature a compact representation (similar to the slope and intercept term in linear regression) and therefore allow for computationally efficient inference. However, non-monotonous shape changes, e.g. present in time-series of cardiac shape motion or anatomical changes in the human brain over the course of decades, do generally not adhere to constraints of geodesicity. Morphomatics provides nonlinear regression for manifold-valued (in particular shape) data based on Riemannian spline models. This framework is very flexible allowing to model geodesics, generalized polynomials, and B\u00e9zier splines (possibly closed). Employing constructive algorithms the provided models still allow for efficient and exact evaluation. Least squares estimation Every Riemannian manifold \\(M\\) (in particular a manifold of shapes) comes with a distance function \\(d\\) . Given parameter-data pairs \\((t_1, p_1),\\dots,(t_n,p_n) \\in \\mathbb{R} \\times M\\) a widely used notion to measure how well a (parametrized) curve \\(\\alpha\\) estimates the data is the sum-of-squared error \\[ \\mathcal{E}(\\alpha) := \\sum_{i=1}^n d(\\alpha(t_i), p_i)^2, \\] that is, the sum of the squared distances from the curve to the data points. A minimizer of \\(\\mathcal{E}\\) (from a class of trajectories) is called least-squares estimator of the data (in this class). Geodesic regression Generalizing the linear ansatz, geodesic regression assumes that the relationship of a manifold-valued observed variable and a (single) co-varying parameter is well approximated by a generalized straight line. It is thus estimated by the geodesic least-squares estimator. The following example for data from the manifold of 3x3 rotation matrices shows how geodesic regression is computed in Morphomatics. import numpy as np from morphomatics.manifold import SO3 from morphomatics.stats import RiemannianRegression \"\"\"Geodesic regression for data in SO(3)\"\"\" M = SO3 () # z-axis is axis of rotation I = np . eye ( 3 ) R = np . array ([[ np . cos ( np . pi / 6 ), - np . sin ( np . pi / 6 ), 0 ], [ np . sin ( np . pi / 6 ), np . cos ( np . pi / 6 ), 0 ], [ 0 , 0 , 1 ]]) # 6 points in SO(3). The extra dimension is not needed here but comes into play when the data consists of # tuples of matrices. Y = np . zeros (( 6 , 1 , 3 , 3 )) Y [ 0 , 0 ] = M . exp ( M . geopoint ( I , R , - 2 / 3 ), np . array ([[ 0 , 0 , 0.1 ], [ 0 , 0 , 0 ], [ - 0.1 , 0 , 0 ]])) Y [ 1 , 0 ] = M . exp ( M . geopoint ( I , R , - 1 / 3 ), np . array ([[ 0 , 0 , 0 ], [ 0 , 0 , 0.2 ], [ 0 , - 0.2 , 0 ]])) Y [ 2 , 0 ] = I Y [ 3 , 0 ] = M . exp ( M . geopoint ( I , R , 1 / 3 ), np . array ([[ 0 , 0 , 0 ], [ 0 , 0 , 0.2 ], [ 0 , - 0.2 , 0 ]])) Y [ 4 , 0 ] = M . exp ( M . geopoint ( I , R , 2 / 3 ), np . array ([[ 0 , 0 , 0.1 ], [ 0 , 0 , 0 ], [ - 0.1 , 0 , 0 ]])) Y [ 5 , 0 ] = R # corresponding time points t = np . array ([ 0 , 1 / 5 , 2 / 5 , 3 / 5 , 4 / 5 , 1 ]) # geodesic has degree 1 degrees = np . array ([ 1 ]) # solve regression = RiemannianRegression ( M , Y , t , degrees ) # geodesic least-squares estimator gam = regression . trend # evaluate geodesic at 100 equidistant points X = gam . eval () To visualize the regressed geodesic, the 100 rotation matrices that were sampled from it as well as the 6 data matrices were applied to the vector \\(q=\\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}^T\\) . The results all lie on the unit sphere; they are shown in the following image. Figure 1 Geodesic regression in SO(3) visualized by applying each matrix to the vector \\(q=\\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}^T\\) . The yellow spheres are the rotations of q by the data points. Applying each of the 100 samples of the optimal geodesic yields the colored curve (color indicating parametrization). Higher-order regression If the relationship between the observed variable and its co-varying parameter is nonlinear (e.g., when there are saturation effects), then geodesic regression is not adequate. Instead, higher-order models are necessary that generalize polynomial regression. In Morphomatics, manifold-valued B\u00e9zier curves are used for this. Apart from being generalized polynomials, they can be constructed explicitly, which allows for fast computations. After model selection, i.e., choosing a degree \\(k\\) , the least squares estimator within the class of B\u00e9zier curves of degree \\(k\\) is the result of the regression. In the following, we show regression with cubic B\u00e9zier curves for the same data as in the example above. import numpy as np from morphomatics.manifold import SO3 from morphomatics.stats import RiemannianRegression \"\"\"Regression with cubic curves for data in SO(3)\"\"\" M = SO3 () # z-axis is axis of rotation I = np . eye ( 3 ) R = np . array ([[ np . cos ( np . pi / 6 ), - np . sin ( np . pi / 6 ), 0 ], [ np . sin ( np . pi / 6 ), np . cos ( np . pi / 6 ), 0 ], [ 0 , 0 , 1 ]]) Y = np . zeros (( 6 , 1 , 3 , 3 )) Y [ 0 , 0 ] = M . exp ( M . geopoint ( I , R , - 2 / 3 ), np . array ([[ 0 , 0 , 0.1 ], [ 0 , 0 , 0 ], [ - 0.1 , 0 , 0 ]])) Y [ 1 , 0 ] = M . exp ( M . geopoint ( I , R , - 1 / 3 ), np . array ([[ 0 , 0 , 0 ], [ 0 , 0 , 0.2 ], [ 0 , - 0.2 , 0 ]])) Y [ 2 , 0 ] = I Y [ 3 , 0 ] = M . exp ( M . geopoint ( I , R , 1 / 3 ), np . array ([[ 0 , 0 , 0 ], [ 0 , 0 , 0.2 ], [ 0 , - 0.2 , 0 ]])) Y [ 4 , 0 ] = M . exp ( M . geopoint ( I , R , 2 / 3 ), np . array ([[ 0 , 0 , 0.1 ], [ 0 , 0 , 0 ], [ - 0.1 , 0 , 0 ]])) Y [ 5 , 0 ] = R # corresponding time points t = np . array ([ 0 , 1 / 5 , 2 / 5 , 3 / 5 , 4 / 5 , 1 ]) # cubic B\u00e9zier curve have degree 3 degrees = np . array ([ 3 ]) # solve regression = RiemannianRegression ( M , Y , t , degrees ) # cubic least-squares estimator bet = regression . trend # evaluate the curve at 100 equidistant points X = bet . eval () The results can be visulized as for geodesic regression. Note that the cubic curve describes the data a lot better than the geodesic. Figure 2 Regression with cubic B\u00e9zier curves in SO(3) visualized by applying each matrix to the vector \\(q=\\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}^T\\) . The yellow spheres are the rotations of q by the data points. Applying each of the 100 samples of the optimal geodesic yields the colored curve (color indicating parametrization). Spline regression Generalized B\u00e9zier curves can be joined together in a differentiable way. The resulting B\u00e9zier splines are very flexible and, thus, allow to describe many phenomena. In particular, since there are closed B\u00e9zier splines, they can be used to model cyclic behavior like the motion of the heart. import numpy as np from morphomatics.manifold import SO3 from morphomatics.stats import RiemannianRegression \"\"\"Regression with closed splines for data in SO(3)\"\"\" M = SO3 () # z-axis is axis of rotation I = np . eye ( 3 ) Rz = np . array ([[ np . cos ( np . pi / 6 ), - np . sin ( np . pi / 6 ), 0 ], [ np . sin ( np . pi / 6 ), np . cos ( np . pi / 6 ), 0 ], [ 0 , 0 , 1 ]]) # x-axis is axis of rotation Rx = np . array ([[ 1 , 0 , 0 ], [ 0 , np . cos ( np . pi / 6 ), - np . sin ( np . pi / 6 )], [ 0 , np . sin ( np . pi / 6 ), np . cos ( np . pi / 6 )]]) Y = np . zeros (( 4 , 1 , 3 , 3 )) Y [ 0 , 0 ] = I Y [ 1 , 0 ] = Rz Y [ 2 , 0 ] = Rx @ Rz Y [ 3 , 0 ] = Rx # spline consisting of 2 cubic segments (first and last segment must be at least cubic) degrees = np . array ([ 3 , 3 ]) # time points between 0 and 2 because we have two segments t = np . array ([ 1 / 3 , 2 / 3 , 4 / 3 , 5 / 3 ]) # solve for closed spline regression = RiemannianRegression ( M , Y , t , degrees , iscycle = True ) # least-squares estimator within the class of closed B\u00e9zier splines with two cubic segments bet = regression . trend # evaluate the spline at 100 equidistant points X = bet . eval ( time = np . linspace ( 0 , bet . nsegments , 100 )) Again, the results can be visualized on the sphere. Note that the computed closed spline interpolates the data points in this case. The reason for this is that we have only 4 data points and the same number of degrees of freedom. In general though, regression assumes noisy measurements and, thus, least-squares optimization and not interpolation is the goal. Figure 3 Regression with closed B\u00e9zier splines consisting of 2 cubic segments in SO(3). Results are visualized by applying each matrix to the vector \\(q=\\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}^T\\) . The yellow spheres are the rotations of q by the data points. Applying each of the 100 samples of the optimal geodesic yields the colored curve (color indicating parametrization).","title":"Regression"},{"location":"tutorial_regression/#manifold-valued-regression","text":"Regression analysis is a reliable statistical approach to estimate the relationship between observed variables, e.g. shapes and their co-varying parameters. For geometric data we again required intrinsic approaches that account for and fully leverage the geometry of the data space. The most widely used is to approximate the observed temporal shape data by geodesics, i.e. generalized straight lines. Geodesic models are attractive as they feature a compact representation (similar to the slope and intercept term in linear regression) and therefore allow for computationally efficient inference. However, non-monotonous shape changes, e.g. present in time-series of cardiac shape motion or anatomical changes in the human brain over the course of decades, do generally not adhere to constraints of geodesicity. Morphomatics provides nonlinear regression for manifold-valued (in particular shape) data based on Riemannian spline models. This framework is very flexible allowing to model geodesics, generalized polynomials, and B\u00e9zier splines (possibly closed). Employing constructive algorithms the provided models still allow for efficient and exact evaluation.","title":"Manifold-valued regression"},{"location":"tutorial_regression/#least-squares-estimation","text":"Every Riemannian manifold \\(M\\) (in particular a manifold of shapes) comes with a distance function \\(d\\) . Given parameter-data pairs \\((t_1, p_1),\\dots,(t_n,p_n) \\in \\mathbb{R} \\times M\\) a widely used notion to measure how well a (parametrized) curve \\(\\alpha\\) estimates the data is the sum-of-squared error \\[ \\mathcal{E}(\\alpha) := \\sum_{i=1}^n d(\\alpha(t_i), p_i)^2, \\] that is, the sum of the squared distances from the curve to the data points. A minimizer of \\(\\mathcal{E}\\) (from a class of trajectories) is called least-squares estimator of the data (in this class).","title":"Least squares estimation"},{"location":"tutorial_regression/#geodesic-regression","text":"Generalizing the linear ansatz, geodesic regression assumes that the relationship of a manifold-valued observed variable and a (single) co-varying parameter is well approximated by a generalized straight line. It is thus estimated by the geodesic least-squares estimator. The following example for data from the manifold of 3x3 rotation matrices shows how geodesic regression is computed in Morphomatics. import numpy as np from morphomatics.manifold import SO3 from morphomatics.stats import RiemannianRegression \"\"\"Geodesic regression for data in SO(3)\"\"\" M = SO3 () # z-axis is axis of rotation I = np . eye ( 3 ) R = np . array ([[ np . cos ( np . pi / 6 ), - np . sin ( np . pi / 6 ), 0 ], [ np . sin ( np . pi / 6 ), np . cos ( np . pi / 6 ), 0 ], [ 0 , 0 , 1 ]]) # 6 points in SO(3). The extra dimension is not needed here but comes into play when the data consists of # tuples of matrices. Y = np . zeros (( 6 , 1 , 3 , 3 )) Y [ 0 , 0 ] = M . exp ( M . geopoint ( I , R , - 2 / 3 ), np . array ([[ 0 , 0 , 0.1 ], [ 0 , 0 , 0 ], [ - 0.1 , 0 , 0 ]])) Y [ 1 , 0 ] = M . exp ( M . geopoint ( I , R , - 1 / 3 ), np . array ([[ 0 , 0 , 0 ], [ 0 , 0 , 0.2 ], [ 0 , - 0.2 , 0 ]])) Y [ 2 , 0 ] = I Y [ 3 , 0 ] = M . exp ( M . geopoint ( I , R , 1 / 3 ), np . array ([[ 0 , 0 , 0 ], [ 0 , 0 , 0.2 ], [ 0 , - 0.2 , 0 ]])) Y [ 4 , 0 ] = M . exp ( M . geopoint ( I , R , 2 / 3 ), np . array ([[ 0 , 0 , 0.1 ], [ 0 , 0 , 0 ], [ - 0.1 , 0 , 0 ]])) Y [ 5 , 0 ] = R # corresponding time points t = np . array ([ 0 , 1 / 5 , 2 / 5 , 3 / 5 , 4 / 5 , 1 ]) # geodesic has degree 1 degrees = np . array ([ 1 ]) # solve regression = RiemannianRegression ( M , Y , t , degrees ) # geodesic least-squares estimator gam = regression . trend # evaluate geodesic at 100 equidistant points X = gam . eval () To visualize the regressed geodesic, the 100 rotation matrices that were sampled from it as well as the 6 data matrices were applied to the vector \\(q=\\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}^T\\) . The results all lie on the unit sphere; they are shown in the following image. Figure 1 Geodesic regression in SO(3) visualized by applying each matrix to the vector \\(q=\\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}^T\\) . The yellow spheres are the rotations of q by the data points. Applying each of the 100 samples of the optimal geodesic yields the colored curve (color indicating parametrization).","title":"Geodesic regression"},{"location":"tutorial_regression/#higher-order-regression","text":"If the relationship between the observed variable and its co-varying parameter is nonlinear (e.g., when there are saturation effects), then geodesic regression is not adequate. Instead, higher-order models are necessary that generalize polynomial regression. In Morphomatics, manifold-valued B\u00e9zier curves are used for this. Apart from being generalized polynomials, they can be constructed explicitly, which allows for fast computations. After model selection, i.e., choosing a degree \\(k\\) , the least squares estimator within the class of B\u00e9zier curves of degree \\(k\\) is the result of the regression. In the following, we show regression with cubic B\u00e9zier curves for the same data as in the example above. import numpy as np from morphomatics.manifold import SO3 from morphomatics.stats import RiemannianRegression \"\"\"Regression with cubic curves for data in SO(3)\"\"\" M = SO3 () # z-axis is axis of rotation I = np . eye ( 3 ) R = np . array ([[ np . cos ( np . pi / 6 ), - np . sin ( np . pi / 6 ), 0 ], [ np . sin ( np . pi / 6 ), np . cos ( np . pi / 6 ), 0 ], [ 0 , 0 , 1 ]]) Y = np . zeros (( 6 , 1 , 3 , 3 )) Y [ 0 , 0 ] = M . exp ( M . geopoint ( I , R , - 2 / 3 ), np . array ([[ 0 , 0 , 0.1 ], [ 0 , 0 , 0 ], [ - 0.1 , 0 , 0 ]])) Y [ 1 , 0 ] = M . exp ( M . geopoint ( I , R , - 1 / 3 ), np . array ([[ 0 , 0 , 0 ], [ 0 , 0 , 0.2 ], [ 0 , - 0.2 , 0 ]])) Y [ 2 , 0 ] = I Y [ 3 , 0 ] = M . exp ( M . geopoint ( I , R , 1 / 3 ), np . array ([[ 0 , 0 , 0 ], [ 0 , 0 , 0.2 ], [ 0 , - 0.2 , 0 ]])) Y [ 4 , 0 ] = M . exp ( M . geopoint ( I , R , 2 / 3 ), np . array ([[ 0 , 0 , 0.1 ], [ 0 , 0 , 0 ], [ - 0.1 , 0 , 0 ]])) Y [ 5 , 0 ] = R # corresponding time points t = np . array ([ 0 , 1 / 5 , 2 / 5 , 3 / 5 , 4 / 5 , 1 ]) # cubic B\u00e9zier curve have degree 3 degrees = np . array ([ 3 ]) # solve regression = RiemannianRegression ( M , Y , t , degrees ) # cubic least-squares estimator bet = regression . trend # evaluate the curve at 100 equidistant points X = bet . eval () The results can be visulized as for geodesic regression. Note that the cubic curve describes the data a lot better than the geodesic. Figure 2 Regression with cubic B\u00e9zier curves in SO(3) visualized by applying each matrix to the vector \\(q=\\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}^T\\) . The yellow spheres are the rotations of q by the data points. Applying each of the 100 samples of the optimal geodesic yields the colored curve (color indicating parametrization).","title":"Higher-order regression"},{"location":"tutorial_regression/#spline-regression","text":"Generalized B\u00e9zier curves can be joined together in a differentiable way. The resulting B\u00e9zier splines are very flexible and, thus, allow to describe many phenomena. In particular, since there are closed B\u00e9zier splines, they can be used to model cyclic behavior like the motion of the heart. import numpy as np from morphomatics.manifold import SO3 from morphomatics.stats import RiemannianRegression \"\"\"Regression with closed splines for data in SO(3)\"\"\" M = SO3 () # z-axis is axis of rotation I = np . eye ( 3 ) Rz = np . array ([[ np . cos ( np . pi / 6 ), - np . sin ( np . pi / 6 ), 0 ], [ np . sin ( np . pi / 6 ), np . cos ( np . pi / 6 ), 0 ], [ 0 , 0 , 1 ]]) # x-axis is axis of rotation Rx = np . array ([[ 1 , 0 , 0 ], [ 0 , np . cos ( np . pi / 6 ), - np . sin ( np . pi / 6 )], [ 0 , np . sin ( np . pi / 6 ), np . cos ( np . pi / 6 )]]) Y = np . zeros (( 4 , 1 , 3 , 3 )) Y [ 0 , 0 ] = I Y [ 1 , 0 ] = Rz Y [ 2 , 0 ] = Rx @ Rz Y [ 3 , 0 ] = Rx # spline consisting of 2 cubic segments (first and last segment must be at least cubic) degrees = np . array ([ 3 , 3 ]) # time points between 0 and 2 because we have two segments t = np . array ([ 1 / 3 , 2 / 3 , 4 / 3 , 5 / 3 ]) # solve for closed spline regression = RiemannianRegression ( M , Y , t , degrees , iscycle = True ) # least-squares estimator within the class of closed B\u00e9zier splines with two cubic segments bet = regression . trend # evaluate the spline at 100 equidistant points X = bet . eval ( time = np . linspace ( 0 , bet . nsegments , 100 )) Again, the results can be visualized on the sphere. Note that the computed closed spline interpolates the data points in this case. The reason for this is that we have only 4 data points and the same number of degrees of freedom. In general though, regression assumes noisy measurements and, thus, least-squares optimization and not interpolation is the goal. Figure 3 Regression with closed B\u00e9zier splines consisting of 2 cubic segments in SO(3). Results are visualized by applying each matrix to the vector \\(q=\\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}^T\\) . The yellow spheres are the rotations of q by the data points. Applying each of the 100 samples of the optimal geodesic yields the colored curve (color indicating parametrization).","title":"Spline regression"},{"location":"tutorial_shape_space/","text":"Shape space A key component in the analysis of shape collections is the notion of a shape space, i.e. a space in which every point corresponds to a particular shape. We will follow a deformation-based approach where a common deformable template encodes the typicality of the object class under study. The shape variability in turn is encoded by deformations of the template (referred to as reference shape in the following). Discrete representation To obtain a computational model, we require a digital representation of shapes and variations thereof. To this end, we employ triangular surface meshes for which we provide the Surface class. A surface mesh is specified by a pair of matrices: \\(v = \\begin{bmatrix} x_0 & y_0 & z_0 \\\\ x_1 & y_1 & z_1 \\\\ & \\vdots & \\end{bmatrix} \\in \\mathbb{R}^{n \\times 3} \\text{ and } f = \\begin{bmatrix} i_0 & j_0 & k_0 \\\\ i_1 & j_1 & k_1 \\\\ & \\vdots & \\end{bmatrix} \\in \\mathbb{R}^{m \\times 3},\\) where \\(v\\) holds the coordinates of \\(n\\) vertices and \\(f\\) lists which vertices (i.e. indices thereof w.r.t. \\(v\\) ) form each of \\(m\\) triangles. For example, we can create a tetrahedron like this: import numpy as np from morphomatics.mesh import Surface # 4 vertices v = np . array ([ [ 0.57735 , 0.57735 , 0.57735 ], [ - 0.57735 , 0.57735 , - 0.57735 ], [ - 0.57735 , - 0.57735 , 0.57735 ], [ 0.57735 , - 0.57735 , - 0.57735 ] ]) # 4 triangles # note: by sharing vertices (each is referenced 3 times), triangles are 'glued' together f = np . array ([ [ 0 , 3 , 1 ], [ 1 , 3 , 2 ], [ 1 , 2 , 0 ], [ 0 , 2 , 3 ] ]) S = Surface ( v , f ) In order to encode deformations, hence shape variations, we focus on simplicial maps, i.e. deformations that map triangles onto triangles and are entirely determined by the images of the vertices. Given a triangulated reference shape \\((\\bar{v}, \\bar{f})\\) , each surface in a collection can be represented by a mesh with same connectivity \\(f_i \\equiv \\bar{f}\\) and mapped vertices \\(v_i = \\phi_i(\\bar{v})\\) . The task of determining the \\(\\phi_i\\) is known as correspondence problem. There is a multitude of approaches to establish correspondence ranging from fully automatic to expert guided ones. The best choice is typically application dependent and we assume that this step has been carried out during pre-process. Shape distance Codifying shapes as simplicial deformations allows to interpret them as elements in the space of vertex coordinates \\(\\mathbb{R}^{n \\times 3}\\) . This configuration space not only encodes the geometric form of objects but also their scale, position and orientation within the 3D space they are embedded in. We can endow this space with a rich geometric structure by equipping it with a non-trivial metric that quantifies shape (dis)similarity. In particular, for shape spaces we require the metric to be invariant under rotations and translations. We can further adopt a physically-based perspective and design the metric to favor natural deformations promising an improved consistency and compact encoding of constraints. The different approaches available within morphomatics are sub-classes of ShapeSpace (in morphomatics.manifold.ShapeSpae ) that in turn inherits from pymanopt 's class Manifold . The available shape spaces are: Point distribution model (see morphomatics.manifold.PointDistributionModel ) A linearized, i.e. Euclidean, shape space mainly for comparison purposes. Rotational and translational effects are reduced via Procrustes alignment to the reference shape. Differential coordinates model (see morphomatics.manifold.DifferentialCoords ) A Riemannian shape space that is able to account for the nonlinearity in shape variation by employing a differential representation that puts the local geometric variability into focus. The differential coordinates are endowed with a Lie group structure that comes with both: Excellent theoretical properties and closed-form expressions yielding simple and efficient algorithms. While translation invariant, rotational effects are reduced via Procrustes alignment to the reference shape. Fundamental coordinates model (see morphomatics.manifold.FundamentalCoords ) A surface-theoretic approach that is invariant under Euclidean motion and thus alignment-free. The rich structure of the derived shape space assures valid shape instances even in presence of strong nonlinear variability. The representation builds upon metric distortion and curvature of shapes as elements of Lie groups that allow for closed-form evaluation of Riemannian operations. Geodesic calculus Due to the lack of familiar properties such as a vector space structure, calculus in non-Euclidean shape spaces can be computationally challenging. Remarkably, the shape space provided here account for the non-linearity in shapes and at the same time offer fast and numerically robust processing. For example, computing geodesic distances or Riemannian exponential/logarithmic maps does not require iterative approximation schemes. S_1 : Surface S_2 : Surface M : ShapeSpace # TODO: load surfaces, init space # map surfaces to shape space coordinates c_1 = M . to_coords ( S_1 . v ) c_2 = M . to_coords ( S_2 . v ) # perform computations, e.g. ... # ... compute distance M . dist ( c_1 , c_2 ) # ... interpolate surfaces (mid-point on geodesic) diff = M . log ( c_1 , c_2 ) mean = M . exp ( c_1 , 0.5 * diff ) # get vertex coordinates of mean v = M . from_coords ( mean )","title":"Shape Space"},{"location":"tutorial_shape_space/#shape-space","text":"A key component in the analysis of shape collections is the notion of a shape space, i.e. a space in which every point corresponds to a particular shape. We will follow a deformation-based approach where a common deformable template encodes the typicality of the object class under study. The shape variability in turn is encoded by deformations of the template (referred to as reference shape in the following).","title":"Shape space"},{"location":"tutorial_shape_space/#discrete-representation","text":"To obtain a computational model, we require a digital representation of shapes and variations thereof. To this end, we employ triangular surface meshes for which we provide the Surface class. A surface mesh is specified by a pair of matrices: \\(v = \\begin{bmatrix} x_0 & y_0 & z_0 \\\\ x_1 & y_1 & z_1 \\\\ & \\vdots & \\end{bmatrix} \\in \\mathbb{R}^{n \\times 3} \\text{ and } f = \\begin{bmatrix} i_0 & j_0 & k_0 \\\\ i_1 & j_1 & k_1 \\\\ & \\vdots & \\end{bmatrix} \\in \\mathbb{R}^{m \\times 3},\\) where \\(v\\) holds the coordinates of \\(n\\) vertices and \\(f\\) lists which vertices (i.e. indices thereof w.r.t. \\(v\\) ) form each of \\(m\\) triangles. For example, we can create a tetrahedron like this: import numpy as np from morphomatics.mesh import Surface # 4 vertices v = np . array ([ [ 0.57735 , 0.57735 , 0.57735 ], [ - 0.57735 , 0.57735 , - 0.57735 ], [ - 0.57735 , - 0.57735 , 0.57735 ], [ 0.57735 , - 0.57735 , - 0.57735 ] ]) # 4 triangles # note: by sharing vertices (each is referenced 3 times), triangles are 'glued' together f = np . array ([ [ 0 , 3 , 1 ], [ 1 , 3 , 2 ], [ 1 , 2 , 0 ], [ 0 , 2 , 3 ] ]) S = Surface ( v , f ) In order to encode deformations, hence shape variations, we focus on simplicial maps, i.e. deformations that map triangles onto triangles and are entirely determined by the images of the vertices. Given a triangulated reference shape \\((\\bar{v}, \\bar{f})\\) , each surface in a collection can be represented by a mesh with same connectivity \\(f_i \\equiv \\bar{f}\\) and mapped vertices \\(v_i = \\phi_i(\\bar{v})\\) . The task of determining the \\(\\phi_i\\) is known as correspondence problem. There is a multitude of approaches to establish correspondence ranging from fully automatic to expert guided ones. The best choice is typically application dependent and we assume that this step has been carried out during pre-process.","title":"Discrete representation"},{"location":"tutorial_shape_space/#shape-distance","text":"Codifying shapes as simplicial deformations allows to interpret them as elements in the space of vertex coordinates \\(\\mathbb{R}^{n \\times 3}\\) . This configuration space not only encodes the geometric form of objects but also their scale, position and orientation within the 3D space they are embedded in. We can endow this space with a rich geometric structure by equipping it with a non-trivial metric that quantifies shape (dis)similarity. In particular, for shape spaces we require the metric to be invariant under rotations and translations. We can further adopt a physically-based perspective and design the metric to favor natural deformations promising an improved consistency and compact encoding of constraints. The different approaches available within morphomatics are sub-classes of ShapeSpace (in morphomatics.manifold.ShapeSpae ) that in turn inherits from pymanopt 's class Manifold . The available shape spaces are: Point distribution model (see morphomatics.manifold.PointDistributionModel ) A linearized, i.e. Euclidean, shape space mainly for comparison purposes. Rotational and translational effects are reduced via Procrustes alignment to the reference shape. Differential coordinates model (see morphomatics.manifold.DifferentialCoords ) A Riemannian shape space that is able to account for the nonlinearity in shape variation by employing a differential representation that puts the local geometric variability into focus. The differential coordinates are endowed with a Lie group structure that comes with both: Excellent theoretical properties and closed-form expressions yielding simple and efficient algorithms. While translation invariant, rotational effects are reduced via Procrustes alignment to the reference shape. Fundamental coordinates model (see morphomatics.manifold.FundamentalCoords ) A surface-theoretic approach that is invariant under Euclidean motion and thus alignment-free. The rich structure of the derived shape space assures valid shape instances even in presence of strong nonlinear variability. The representation builds upon metric distortion and curvature of shapes as elements of Lie groups that allow for closed-form evaluation of Riemannian operations.","title":"Shape distance"},{"location":"tutorial_shape_space/#geodesic-calculus","text":"Due to the lack of familiar properties such as a vector space structure, calculus in non-Euclidean shape spaces can be computationally challenging. Remarkably, the shape space provided here account for the non-linearity in shapes and at the same time offer fast and numerically robust processing. For example, computing geodesic distances or Riemannian exponential/logarithmic maps does not require iterative approximation schemes. S_1 : Surface S_2 : Surface M : ShapeSpace # TODO: load surfaces, init space # map surfaces to shape space coordinates c_1 = M . to_coords ( S_1 . v ) c_2 = M . to_coords ( S_2 . v ) # perform computations, e.g. ... # ... compute distance M . dist ( c_1 , c_2 ) # ... interpolate surfaces (mid-point on geodesic) diff = M . log ( c_1 , c_2 ) mean = M . exp ( c_1 , 0.5 * diff ) # get vertex coordinates of mean v = M . from_coords ( mean )","title":"Geodesic calculus"},{"location":"tutorial_ssm/","text":"Statistical shape modeling Statistical shape models (SSMs) provide a principled way for extracting knowledge from empirically given collections of objects. Instead of considering only a few quantities derived from a shape, such as volume, studying shapes in their entirety allows for a full geometric characterization and hence more differentiated assertions about the shapes. SSMs describe the geometric variability in a collection in terms of a mean shape and a hierarchy of major modes explaining the main trends of shape variation. Based on a notion of shape space, SSMs can be learned from consistently parametrized instances from the object class under study. The resulting models provide a shape prior that can be used to constrain synthesis and analysis problems. Moreover, their parameter space provides a compact representation that is amenable to learning algorithms (e.g. classification or clustering), evaluation, and exploration. Intrinsic mean \\(\\mu = \\arg\\min_x \\sum_i \\text{dist}^2(x,x_i)\\) Principal geodesic analysis","title":"Statistical Shape Modeling"},{"location":"tutorial_ssm/#statistical-shape-modeling","text":"Statistical shape models (SSMs) provide a principled way for extracting knowledge from empirically given collections of objects. Instead of considering only a few quantities derived from a shape, such as volume, studying shapes in their entirety allows for a full geometric characterization and hence more differentiated assertions about the shapes. SSMs describe the geometric variability in a collection in terms of a mean shape and a hierarchy of major modes explaining the main trends of shape variation. Based on a notion of shape space, SSMs can be learned from consistently parametrized instances from the object class under study. The resulting models provide a shape prior that can be used to constrain synthesis and analysis problems. Moreover, their parameter space provides a compact representation that is amenable to learning algorithms (e.g. classification or clustering), evaluation, and exploration.","title":"Statistical shape modeling"},{"location":"tutorial_ssm/#intrinsic-mean","text":"\\(\\mu = \\arg\\min_x \\sum_i \\text{dist}^2(x,x_i)\\)","title":"Intrinsic mean"},{"location":"tutorial_ssm/#principal-geodesic-analysis","text":"","title":"Principal geodesic analysis"}]}