{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Morphomatics: Geometric morphometrics in non-Euclidean shape spaces Morphomatics is an open-source Python library for (statistical) shape analysis developed within the geometric data analysis and processing research group at Zuse Institute Berlin. It contains prototype implementations of intrinsic manifold-based methods that are highly consistent and avoid the influence of unwanted effects such as bias due to arbitrary choices of coordinates. The source code is freely available on GitHub. Citation If you use Morphomatics in your academic projects, we politely ask you to aknowledge Morphomatics in your manuscript and to cite each of the publications (listed below) that are relevant for your use. You may cite the library in general using this BibTeX entry: @misc { Morphomatics , title = {Morphomatics: Geometric morphometrics in non-Euclidean shape spaces} , author = {Felix Ambellan and Martin Hanik and Christoph von Tycowicz} , note = {https://morphomatics.github.io/} , year = {2021} , } Of course, if you want, we will also list a reference to your work/project/etc. here. Riemannian shape spaces We provide a novel Riemannian framework for shape analysis based on differential coordinates that naturally belong to Lie groups and effectively describe local changes in shape. Performing intrinsic calculus on this representation allows for fast computations while, at the same time, accounts for the nonlinearity in shape variation. The rich structure of the derived shape space yields highly discriminative shape descriptors providing a compact representation that is amenable to learning algorithms. References: Christoph von Tycowicz, Felix Ambellan, Anirban Mukhopadhyay, and Stefan Zachow: An Efficient Riemannian Statistical Shape Model using Differential Coordinates. Medical Image Analysis, Volume 43, January 2018. Felix Ambellan, Stefan Zachow, and Christoph von Tycowicz: Rigid Motion Invariant Statistical Shape Modeling Based on Discrete Fundamental Forms. Medical Image Analysis, Volume 73, January 2021. Manifold-valued regression References: Martin Hanik, Hans-Christian Hege, Anja Hennemuth, Christoph von Tycowicz: Nonlinear Regression on Manifolds for Shape Analysis using Intrinsic B\u00e9zier Splines. Proc. Medical Image Computing and Computer Assisted Intervention (MICCAI), 2020. Applications Several applications have been successively developed based on algorithms from Morphomatics: Geodesic B-Score [Ambellan et al. 21] (arXiv) Thin-Volume Visualization [Herter et al. 21] Jerash Silver Scroll Unfolding [Baum et al. 21] Contributors Christoph von Tycowicz Felix Ambellan Martin Hanik","title":"Home"},{"location":"#morphomatics-geometric-morphometrics-in-non-euclidean-shape-spaces","text":"Morphomatics is an open-source Python library for (statistical) shape analysis developed within the geometric data analysis and processing research group at Zuse Institute Berlin. It contains prototype implementations of intrinsic manifold-based methods that are highly consistent and avoid the influence of unwanted effects such as bias due to arbitrary choices of coordinates. The source code is freely available on GitHub.","title":"Morphomatics: Geometric morphometrics in non-Euclidean shape spaces"},{"location":"#citation","text":"If you use Morphomatics in your academic projects, we politely ask you to aknowledge Morphomatics in your manuscript and to cite each of the publications (listed below) that are relevant for your use. You may cite the library in general using this BibTeX entry: @misc { Morphomatics , title = {Morphomatics: Geometric morphometrics in non-Euclidean shape spaces} , author = {Felix Ambellan and Martin Hanik and Christoph von Tycowicz} , note = {https://morphomatics.github.io/} , year = {2021} , } Of course, if you want, we will also list a reference to your work/project/etc. here.","title":"Citation"},{"location":"#riemannian-shape-spaces","text":"We provide a novel Riemannian framework for shape analysis based on differential coordinates that naturally belong to Lie groups and effectively describe local changes in shape. Performing intrinsic calculus on this representation allows for fast computations while, at the same time, accounts for the nonlinearity in shape variation. The rich structure of the derived shape space yields highly discriminative shape descriptors providing a compact representation that is amenable to learning algorithms. References: Christoph von Tycowicz, Felix Ambellan, Anirban Mukhopadhyay, and Stefan Zachow: An Efficient Riemannian Statistical Shape Model using Differential Coordinates. Medical Image Analysis, Volume 43, January 2018. Felix Ambellan, Stefan Zachow, and Christoph von Tycowicz: Rigid Motion Invariant Statistical Shape Modeling Based on Discrete Fundamental Forms. Medical Image Analysis, Volume 73, January 2021.","title":"Riemannian shape spaces"},{"location":"#manifold-valued-regression","text":"References: Martin Hanik, Hans-Christian Hege, Anja Hennemuth, Christoph von Tycowicz: Nonlinear Regression on Manifolds for Shape Analysis using Intrinsic B\u00e9zier Splines. Proc. Medical Image Computing and Computer Assisted Intervention (MICCAI), 2020.","title":"Manifold-valued regression"},{"location":"#applications","text":"Several applications have been successively developed based on algorithms from Morphomatics: Geodesic B-Score [Ambellan et al. 21] (arXiv) Thin-Volume Visualization [Herter et al. 21] Jerash Silver Scroll Unfolding [Baum et al. 21]","title":"Applications"},{"location":"#contributors","text":"Christoph von Tycowicz Felix Ambellan Martin Hanik","title":"Contributors"},{"location":"imprint/","text":"Imprint Christoph von Tycowicz Glandzeile 7 12205 Berlin cvt[at]tycowicz.de Verantwortlich im Sinne des \u00a75 Abs. 1 TMG: Christoph von Tycowicz Verantwortlich im Sinne des \u00a755 Abs. 2 RStV: Christoph von Tycowicz Verantwortlich f\u00fcr die Inhalte (Texte, Bilder) dieser Seite: Christoph von Tycowicz Morphomatics Logo: Designed by Maestro99 / Freepik Haftung f\u00fcr Inhalte Als Diensteanbieter bin ich gem\u00e4\u00df \u00a7 7 Abs.1 TMG f\u00fcr eigene Inhalte auf diesen Seiten nach den allgemeinen Gesetzen verantwortlich. Nach \u00a7\u00a7 8 bis 10 TMG bin ich als Diensteanbieter jedoch nicht verpflichtet, \u00fcbermittelte oder gespeicherte fremde Informationen zu \u00fcberwachen oder nach Umst\u00e4nden zu forschen, die auf eine rechtswidrige T\u00e4tigkeit hinweisen. Verpflichtungen zur Entfernung oder Sperrung der Nutzung von Informationen nach den allgemeinen Gesetzen bleiben hiervon unber\u00fchrt. Eine diesbez\u00fcgliche Haftung ist jedoch erst ab dem Zeitpunkt der Kenntnis einer konkreten Rechtsverletzung m\u00f6glich. Bei Bekanntwerden von entsprechenden Rechtsverletzungen werde ich diese Inhalte umgehend entfernen. Haftung f\u00fcr Links Mein Angebot enth\u00e4lt Links zu externen Webseiten Dritter, auf deren Inhalte ich keinen Einfluss habe. Deshalb kann ich f\u00fcr diese fremden Inhalte auch keine Gew\u00e4hr \u00fcbernehmen. F\u00fcr die Inhalte der verlinkten Seiten ist stets der jeweilige Anbieter oder Betreiber der Seiten verantwortlich. Die verlinkten Seiten wurden zum Zeitpunkt der Verlinkung auf m\u00f6gliche Rechtsverst\u00f6\u00dfe \u00fcberpr\u00fcft. Rechtswidrige Inhalte waren zum Zeitpunkt der Verlinkung nicht erkennbar. Eine permanente inhaltliche Kontrolle der verlinkten Seiten ist jedoch ohne konkrete Anhaltspunkte einer Rechtsverletzung nicht zumutbar. Bei Bekanntwerden von Rechtsverletzungen werde ich derartige Links umgehend entfernen. Urheberrecht Die durch die Seitenbetreiber erstellten Inhalte und Werke auf diesen Seiten unterliegen dem deutschen Urheberrecht. Die Vervielf\u00e4ltigung, Bearbeitung, Verbreitung und jede Art der Verwertung au\u00dferhalb der Grenzen des Urheberrechtes bed\u00fcrfen der schriftlichen Zustimmung des jeweiligen Autors bzw. Erstellers. Downloads und Kopien dieser Seite sind nur f\u00fcr den privaten, nicht kommerziellen Gebrauch gestattet. Soweit die Inhalte auf dieser Seite nicht vom Betreiber erstellt wurden, werden die Urheberrechte Dritter beachtet. Insbesondere werden Inhalte Dritter als solche gekennzeichnet. Sollten Sie trotzdem auf eine Urheberrechtsverletzung aufmerksam werden, bitte ich um einen entsprechenden Hinweis. Bei Bekanntwerden von Rechtsverletzungen werde ich derartige Inhalte umgehend entfernen. Google Analytics Diese Website benutzt Google Analytics, einen Webanalysedienst der Google Inc. (\u201eGoogle\u201c). Google Analytics verwendet sog. \u201eCookies\u201c, Textdateien, die auf Ihrem Computer gespeichert werden und die eine Analyse der Benutzung der Website durch Sie erm\u00f6glichen. Die durch den Cookie erzeugten Informationen \u00fcber Ihre Benutzung dieser Website werden in der Regel an einen Server von Google in den USA \u00fcbertragen und dort gespeichert. Im Falle der Aktivierung der IP-Anonymisierung auf dieser Webseite, wird Ihre IP-Adresse von Google jedoch innerhalb von Mitgliedstaaten der Europ\u00e4ischen Union oder in anderen Vertragsstaaten des Abkommens \u00fcber den Europ\u00e4ischen Wirtschaftsraum zuvor gek\u00fcrzt. Nur in Ausnahmef\u00e4llen wird die volle IP-Adresse an einen Server von Google in den USA \u00fcbertragen und dort gek\u00fcrzt. Im Auftrag des Betreibers dieser Website wird Google diese Informationen benutzen, um Ihre Nutzung der Website auszuwerten, um Reports \u00fcber die Websiteaktivit\u00e4ten zusammenzustellen und um weitere mit der Websitenutzung und der Internetnutzung verbundene Dienstleistungen gegen\u00fcber dem Websitebetreiber zu erbringen. Die im Rahmen von Google Analytics von Ihrem Browser \u00fcbermittelte IP-Adresse wird nicht mit anderen Daten von Google zusammengef\u00fchrt. Sie k\u00f6nnen die Speicherung der Cookies durch eine entsprechende Einstellung Ihrer Browser-Software verhindern; wir weisen Sie jedoch darauf hin, dass Sie in diesem Fall gegebenenfalls nicht s\u00e4mtliche Funktionen dieser Website vollumf\u00e4nglich werden nutzen k\u00f6nnen. Sie k\u00f6nnen dar\u00fcber hinaus die Erfassung der durch das Cookie erzeugten und auf Ihre Nutzung der Website bezogenen Daten (inkl. Ihrer IP-Adresse) an Google sowie die Verarbeitung dieser Daten durch Google verhindern, indem Sie das unter dem folgenden Link verf\u00fcgbare Browser-Plugin herunterladen und installieren: http://tools.google.com/dlpage/gaoptout N\u00e4here Informationen zu Nutzungsbedingungen und Datenschutz finden Sie unter den Google Analytics Bedingungen bzw. unter der Google Analytics \u00dcbersicht. Wir weisen Sie darauf hin, dass auf dieser Webseite Google Analytics um den Code \u201cgat._anonymizeIp();\u201d erweitert wurde, um eine anonymisierte Erfassung von IP-Adressen (sog. IP-Masking) zu gew\u00e4hrleisten.","title":"Imprint"},{"location":"imprint/#imprint","text":"Christoph von Tycowicz Glandzeile 7 12205 Berlin cvt[at]tycowicz.de Verantwortlich im Sinne des \u00a75 Abs. 1 TMG: Christoph von Tycowicz Verantwortlich im Sinne des \u00a755 Abs. 2 RStV: Christoph von Tycowicz Verantwortlich f\u00fcr die Inhalte (Texte, Bilder) dieser Seite: Christoph von Tycowicz Morphomatics Logo: Designed by Maestro99 / Freepik","title":"Imprint"},{"location":"imprint/#haftung-fur-inhalte","text":"Als Diensteanbieter bin ich gem\u00e4\u00df \u00a7 7 Abs.1 TMG f\u00fcr eigene Inhalte auf diesen Seiten nach den allgemeinen Gesetzen verantwortlich. Nach \u00a7\u00a7 8 bis 10 TMG bin ich als Diensteanbieter jedoch nicht verpflichtet, \u00fcbermittelte oder gespeicherte fremde Informationen zu \u00fcberwachen oder nach Umst\u00e4nden zu forschen, die auf eine rechtswidrige T\u00e4tigkeit hinweisen. Verpflichtungen zur Entfernung oder Sperrung der Nutzung von Informationen nach den allgemeinen Gesetzen bleiben hiervon unber\u00fchrt. Eine diesbez\u00fcgliche Haftung ist jedoch erst ab dem Zeitpunkt der Kenntnis einer konkreten Rechtsverletzung m\u00f6glich. Bei Bekanntwerden von entsprechenden Rechtsverletzungen werde ich diese Inhalte umgehend entfernen.","title":"Haftung f\u00fcr Inhalte"},{"location":"imprint/#haftung-fur-links","text":"Mein Angebot enth\u00e4lt Links zu externen Webseiten Dritter, auf deren Inhalte ich keinen Einfluss habe. Deshalb kann ich f\u00fcr diese fremden Inhalte auch keine Gew\u00e4hr \u00fcbernehmen. F\u00fcr die Inhalte der verlinkten Seiten ist stets der jeweilige Anbieter oder Betreiber der Seiten verantwortlich. Die verlinkten Seiten wurden zum Zeitpunkt der Verlinkung auf m\u00f6gliche Rechtsverst\u00f6\u00dfe \u00fcberpr\u00fcft. Rechtswidrige Inhalte waren zum Zeitpunkt der Verlinkung nicht erkennbar. Eine permanente inhaltliche Kontrolle der verlinkten Seiten ist jedoch ohne konkrete Anhaltspunkte einer Rechtsverletzung nicht zumutbar. Bei Bekanntwerden von Rechtsverletzungen werde ich derartige Links umgehend entfernen.","title":"Haftung f\u00fcr Links"},{"location":"imprint/#urheberrecht","text":"Die durch die Seitenbetreiber erstellten Inhalte und Werke auf diesen Seiten unterliegen dem deutschen Urheberrecht. Die Vervielf\u00e4ltigung, Bearbeitung, Verbreitung und jede Art der Verwertung au\u00dferhalb der Grenzen des Urheberrechtes bed\u00fcrfen der schriftlichen Zustimmung des jeweiligen Autors bzw. Erstellers. Downloads und Kopien dieser Seite sind nur f\u00fcr den privaten, nicht kommerziellen Gebrauch gestattet. Soweit die Inhalte auf dieser Seite nicht vom Betreiber erstellt wurden, werden die Urheberrechte Dritter beachtet. Insbesondere werden Inhalte Dritter als solche gekennzeichnet. Sollten Sie trotzdem auf eine Urheberrechtsverletzung aufmerksam werden, bitte ich um einen entsprechenden Hinweis. Bei Bekanntwerden von Rechtsverletzungen werde ich derartige Inhalte umgehend entfernen.","title":"Urheberrecht"},{"location":"imprint/#google-analytics","text":"Diese Website benutzt Google Analytics, einen Webanalysedienst der Google Inc. (\u201eGoogle\u201c). Google Analytics verwendet sog. \u201eCookies\u201c, Textdateien, die auf Ihrem Computer gespeichert werden und die eine Analyse der Benutzung der Website durch Sie erm\u00f6glichen. Die durch den Cookie erzeugten Informationen \u00fcber Ihre Benutzung dieser Website werden in der Regel an einen Server von Google in den USA \u00fcbertragen und dort gespeichert. Im Falle der Aktivierung der IP-Anonymisierung auf dieser Webseite, wird Ihre IP-Adresse von Google jedoch innerhalb von Mitgliedstaaten der Europ\u00e4ischen Union oder in anderen Vertragsstaaten des Abkommens \u00fcber den Europ\u00e4ischen Wirtschaftsraum zuvor gek\u00fcrzt. Nur in Ausnahmef\u00e4llen wird die volle IP-Adresse an einen Server von Google in den USA \u00fcbertragen und dort gek\u00fcrzt. Im Auftrag des Betreibers dieser Website wird Google diese Informationen benutzen, um Ihre Nutzung der Website auszuwerten, um Reports \u00fcber die Websiteaktivit\u00e4ten zusammenzustellen und um weitere mit der Websitenutzung und der Internetnutzung verbundene Dienstleistungen gegen\u00fcber dem Websitebetreiber zu erbringen. Die im Rahmen von Google Analytics von Ihrem Browser \u00fcbermittelte IP-Adresse wird nicht mit anderen Daten von Google zusammengef\u00fchrt. Sie k\u00f6nnen die Speicherung der Cookies durch eine entsprechende Einstellung Ihrer Browser-Software verhindern; wir weisen Sie jedoch darauf hin, dass Sie in diesem Fall gegebenenfalls nicht s\u00e4mtliche Funktionen dieser Website vollumf\u00e4nglich werden nutzen k\u00f6nnen. Sie k\u00f6nnen dar\u00fcber hinaus die Erfassung der durch das Cookie erzeugten und auf Ihre Nutzung der Website bezogenen Daten (inkl. Ihrer IP-Adresse) an Google sowie die Verarbeitung dieser Daten durch Google verhindern, indem Sie das unter dem folgenden Link verf\u00fcgbare Browser-Plugin herunterladen und installieren: http://tools.google.com/dlpage/gaoptout N\u00e4here Informationen zu Nutzungsbedingungen und Datenschutz finden Sie unter den Google Analytics Bedingungen bzw. unter der Google Analytics \u00dcbersicht. Wir weisen Sie darauf hin, dass auf dieser Webseite Google Analytics um den Code \u201cgat._anonymizeIp();\u201d erweitert wurde, um eine anonymisierte Erfassung von IP-Adressen (sog. IP-Masking) zu gew\u00e4hrleisten.","title":"Google Analytics"},{"location":"tutorial_regression/","text":"Manifold-valued regression Regression analysis is a reliable statistical approach to estimate the relationship between observed variables, e.g. shapes and their co-varying parameters. For geometric data we again required intrinsic approaches that account for and fully leverage the geometry of the data space. The most widely used is to approximate the observed temporal shape data by geodesics, i.e. generalized straight lines. Geodesic models are attractive as they feature a compact representation (similar to the slope and intercept term in linear regression) and therefore allow for computationally efficient inference. However, non-monotonous shape changes, e.g. present in time-series of cardiac shape motion or anatomical changes in the human brain over the course of decades, do generally not adhere to constraints of geodesicity. Morphomatics provides nonlinear regression for manifold-valued (in particular shape) data based on Riemannian spline models. This framework is very flexible allowing to model geodesics, generalized polynomials, and B\u00e9zier splines (possibly closed). Employing constructive algorithms the provided models still allow for efficient and exact evaluation. Least squares estimation Every Riemannian manifold \\(M\\) (in particular a manifold of shapes) comes with a distance function \\(d\\) . Given parameter-data pairs \\((t_1, p_1),\\dots,(t_n,p_n) \\in \\mathbb{R} \\times M\\) a widely used notion to measure how well a (parametrized) curve \\(\\alpha\\) estimates the data is the sum-of-squared error \\[ \\mathcal{E}(\\alpha) := \\sum_{i=1}^n d(\\alpha(t_i), p_i)^2, \\] that is, the sum of the squared distances from the curve to the data points. A minimizer of \\(\\mathcal{E}\\) (from a class of trajectories) is called least-squares estimator of the data (in this class). Geodesic regression Generalizing the linear ansatz, geodesic regression assumes that the relationship of a manifold-valued observed variable and a (single) co-varying parameter is well approximated by a generalized straight line. It is thus estimated by the geodesic least-squares estimator. The following example for data from the manifold of 3x3 rotation matrices shows how geodesic regression is computed in Morphomatics. import numpy as np from morphomatics.manifold import SO3 from morphomatics.stats import RiemannianRegression \"\"\"Geodesic regression for data in SO(3)\"\"\" M = SO3 () # z-axis is axis of rotation I = np . eye ( 3 ) R = np . array ([[ np . cos ( np . pi / 6 ), - np . sin ( np . pi / 6 ), 0 ], [ np . sin ( np . pi / 6 ), np . cos ( np . pi / 6 ), 0 ], [ 0 , 0 , 1 ]]) # 6 points in SO(3). The extra dimension is not needed here but comes into play when the data consists of # tuples of matrices. Y = np . zeros (( 6 , 1 , 3 , 3 )) Y [ 0 , 0 ] = M . exp ( M . geopoint ( I , R , - 2 / 3 ), np . array ([[ 0 , 0 , 0.1 ], [ 0 , 0 , 0 ], [ - 0.1 , 0 , 0 ]])) Y [ 1 , 0 ] = M . exp ( M . geopoint ( I , R , - 1 / 3 ), np . array ([[ 0 , 0 , 0 ], [ 0 , 0 , 0.2 ], [ 0 , - 0.2 , 0 ]])) Y [ 2 , 0 ] = I Y [ 3 , 0 ] = M . exp ( M . geopoint ( I , R , 1 / 3 ), np . array ([[ 0 , 0 , 0 ], [ 0 , 0 , 0.2 ], [ 0 , - 0.2 , 0 ]])) Y [ 4 , 0 ] = M . exp ( M . geopoint ( I , R , 2 / 3 ), np . array ([[ 0 , 0 , 0.1 ], [ 0 , 0 , 0 ], [ - 0.1 , 0 , 0 ]])) Y [ 5 , 0 ] = R # corresponding time points t = np . array ([ 0 , 1 / 5 , 2 / 5 , 3 / 5 , 4 / 5 , 1 ]) # geodesic has degree 1 degrees = np . array ([ 1 ]) # solve regression = RiemannianRegression ( M , Y , t , degrees ) # geodesic least-squares estimator gam = regression . trend # evaluate geodesic at 100 equidistant points X = gam . eval () To visualize the regressed geodesic, the 100 rotation matrices that were sampled from it as well as the 6 data matrices were applied to the vector \\(q=\\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}^T\\) . The results all lie on the unit sphere; they are shown in the following image. Figure 1 Geodesic regression in SO(3) visualized by applying each matrix to the vector \\(q=\\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}^T\\) . The yellow spheres are the rotations of q by the data points. Applying each of the 100 samples of the optimal geodesic yields the colored curve (color indicating parametrization). Higher-order regression If the relationship between the observed variable and its co-varying parameter is nonlinear (e.g., when there are saturation effects), then geodesic regression is not adequate. Instead, higher-order models are necessary that generalize polynomial regression. In Morphomatics, manifold-valued B\u00e9zier curves are used for this. Apart from being generalized polynomials, they can be constructed explicitly, which allows for fast computations. After model selection, i.e., choosing a degree \\(k\\) , the least squares estimator within the class of B\u00e9zier curves of degree \\(k\\) is the result of the regression. In the following, we show regression with cubic B\u00e9zier curves for the same data as in the example above. import numpy as np from morphomatics.manifold import SO3 from morphomatics.stats import RiemannianRegression \"\"\"Regression with cubic curves for data in SO(3)\"\"\" M = SO3 () # z-axis is axis of rotation I = np . eye ( 3 ) R = np . array ([[ np . cos ( np . pi / 6 ), - np . sin ( np . pi / 6 ), 0 ], [ np . sin ( np . pi / 6 ), np . cos ( np . pi / 6 ), 0 ], [ 0 , 0 , 1 ]]) Y = np . zeros (( 6 , 1 , 3 , 3 )) Y [ 0 , 0 ] = M . exp ( M . geopoint ( I , R , - 2 / 3 ), np . array ([[ 0 , 0 , 0.1 ], [ 0 , 0 , 0 ], [ - 0.1 , 0 , 0 ]])) Y [ 1 , 0 ] = M . exp ( M . geopoint ( I , R , - 1 / 3 ), np . array ([[ 0 , 0 , 0 ], [ 0 , 0 , 0.2 ], [ 0 , - 0.2 , 0 ]])) Y [ 2 , 0 ] = I Y [ 3 , 0 ] = M . exp ( M . geopoint ( I , R , 1 / 3 ), np . array ([[ 0 , 0 , 0 ], [ 0 , 0 , 0.2 ], [ 0 , - 0.2 , 0 ]])) Y [ 4 , 0 ] = M . exp ( M . geopoint ( I , R , 2 / 3 ), np . array ([[ 0 , 0 , 0.1 ], [ 0 , 0 , 0 ], [ - 0.1 , 0 , 0 ]])) Y [ 5 , 0 ] = R # corresponding time points t = np . array ([ 0 , 1 / 5 , 2 / 5 , 3 / 5 , 4 / 5 , 1 ]) # cubic B\u00e9zier curve have degree 3 degrees = np . array ([ 3 ]) # solve regression = RiemannianRegression ( M , Y , t , degrees ) # cubic least-squares estimator bet = regression . trend # evaluate the curve at 100 equidistant points X = bet . eval () The results can be visulized as for geodesic regression. Note that the cubic curve describes the data a lot better than the geodesic. Figure 2 Regression with cubic B\u00e9zier curves in SO(3) visualized by applying each matrix to the vector \\(q=\\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}^T\\) . The yellow spheres are the rotations of q by the data points. Applying each of the 100 samples of the optimal geodesic yields the colored curve (color indicating parametrization). Spline regression Generalized B\u00e9zier curves can be joined together in a differentiable way. The resulting B\u00e9zier splines are very flexible and, thus, allow to describe many phenomena. In particular, since there are closed B\u00e9zier splines, they can be used to model cyclic behavior like the motion of the heart. import numpy as np from morphomatics.manifold import SO3 from morphomatics.stats import RiemannianRegression \"\"\"Regression with closed splines for data in SO(3)\"\"\" M = SO3 () # z-axis is axis of rotation I = np . eye ( 3 ) Rz = np . array ([[ np . cos ( np . pi / 6 ), - np . sin ( np . pi / 6 ), 0 ], [ np . sin ( np . pi / 6 ), np . cos ( np . pi / 6 ), 0 ], [ 0 , 0 , 1 ]]) # x-axis is axis of rotation Rx = np . array ([[ 1 , 0 , 0 ], [ 0 , np . cos ( np . pi / 6 ), - np . sin ( np . pi / 6 )], [ 0 , np . sin ( np . pi / 6 ), np . cos ( np . pi / 6 )]]) Y = np . zeros (( 4 , 1 , 3 , 3 )) Y [ 0 , 0 ] = I Y [ 1 , 0 ] = Rz Y [ 2 , 0 ] = Rx @ Rz Y [ 3 , 0 ] = Rx # spline consisting of 2 cubic segments (first and last segment must be at least cubic) degrees = np . array ([ 3 , 3 ]) # time points between 0 and 2 because we have two segments t = np . array ([ 1 / 3 , 2 / 3 , 4 / 3 , 5 / 3 ]) # solve for closed spline regression = RiemannianRegression ( M , Y , t , degrees , iscycle = True ) # least-squares estimator within the class of closed B\u00e9zier splines with two cubic segments bet = regression . trend # evaluate the spline at 100 equidistant points X = bet . eval ( time = np . linspace ( 0 , bet . nsegments , 100 )) Again, the results can be visualized on the sphere. Note that the computed closed spline interpolates the data points in this case. The reason for this is that we have only 4 data points and the same number of degrees of freedom. In general though, regression assumes noisy measurements and, thus, least-squares optimization and not interpolation is the goal. Figure 3 Regression with closed B\u00e9zier splines consisting of 2 cubic segments in SO(3). Results are visualized by applying each matrix to the vector \\(q=\\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}^T\\) . The yellow spheres are the rotations of q by the data points. Applying each of the 100 samples of the optimal geodesic yields the colored curve (color indicating parametrization).","title":"Regression"},{"location":"tutorial_regression/#manifold-valued-regression","text":"Regression analysis is a reliable statistical approach to estimate the relationship between observed variables, e.g. shapes and their co-varying parameters. For geometric data we again required intrinsic approaches that account for and fully leverage the geometry of the data space. The most widely used is to approximate the observed temporal shape data by geodesics, i.e. generalized straight lines. Geodesic models are attractive as they feature a compact representation (similar to the slope and intercept term in linear regression) and therefore allow for computationally efficient inference. However, non-monotonous shape changes, e.g. present in time-series of cardiac shape motion or anatomical changes in the human brain over the course of decades, do generally not adhere to constraints of geodesicity. Morphomatics provides nonlinear regression for manifold-valued (in particular shape) data based on Riemannian spline models. This framework is very flexible allowing to model geodesics, generalized polynomials, and B\u00e9zier splines (possibly closed). Employing constructive algorithms the provided models still allow for efficient and exact evaluation.","title":"Manifold-valued regression"},{"location":"tutorial_regression/#least-squares-estimation","text":"Every Riemannian manifold \\(M\\) (in particular a manifold of shapes) comes with a distance function \\(d\\) . Given parameter-data pairs \\((t_1, p_1),\\dots,(t_n,p_n) \\in \\mathbb{R} \\times M\\) a widely used notion to measure how well a (parametrized) curve \\(\\alpha\\) estimates the data is the sum-of-squared error \\[ \\mathcal{E}(\\alpha) := \\sum_{i=1}^n d(\\alpha(t_i), p_i)^2, \\] that is, the sum of the squared distances from the curve to the data points. A minimizer of \\(\\mathcal{E}\\) (from a class of trajectories) is called least-squares estimator of the data (in this class).","title":"Least squares estimation"},{"location":"tutorial_regression/#geodesic-regression","text":"Generalizing the linear ansatz, geodesic regression assumes that the relationship of a manifold-valued observed variable and a (single) co-varying parameter is well approximated by a generalized straight line. It is thus estimated by the geodesic least-squares estimator. The following example for data from the manifold of 3x3 rotation matrices shows how geodesic regression is computed in Morphomatics. import numpy as np from morphomatics.manifold import SO3 from morphomatics.stats import RiemannianRegression \"\"\"Geodesic regression for data in SO(3)\"\"\" M = SO3 () # z-axis is axis of rotation I = np . eye ( 3 ) R = np . array ([[ np . cos ( np . pi / 6 ), - np . sin ( np . pi / 6 ), 0 ], [ np . sin ( np . pi / 6 ), np . cos ( np . pi / 6 ), 0 ], [ 0 , 0 , 1 ]]) # 6 points in SO(3). The extra dimension is not needed here but comes into play when the data consists of # tuples of matrices. Y = np . zeros (( 6 , 1 , 3 , 3 )) Y [ 0 , 0 ] = M . exp ( M . geopoint ( I , R , - 2 / 3 ), np . array ([[ 0 , 0 , 0.1 ], [ 0 , 0 , 0 ], [ - 0.1 , 0 , 0 ]])) Y [ 1 , 0 ] = M . exp ( M . geopoint ( I , R , - 1 / 3 ), np . array ([[ 0 , 0 , 0 ], [ 0 , 0 , 0.2 ], [ 0 , - 0.2 , 0 ]])) Y [ 2 , 0 ] = I Y [ 3 , 0 ] = M . exp ( M . geopoint ( I , R , 1 / 3 ), np . array ([[ 0 , 0 , 0 ], [ 0 , 0 , 0.2 ], [ 0 , - 0.2 , 0 ]])) Y [ 4 , 0 ] = M . exp ( M . geopoint ( I , R , 2 / 3 ), np . array ([[ 0 , 0 , 0.1 ], [ 0 , 0 , 0 ], [ - 0.1 , 0 , 0 ]])) Y [ 5 , 0 ] = R # corresponding time points t = np . array ([ 0 , 1 / 5 , 2 / 5 , 3 / 5 , 4 / 5 , 1 ]) # geodesic has degree 1 degrees = np . array ([ 1 ]) # solve regression = RiemannianRegression ( M , Y , t , degrees ) # geodesic least-squares estimator gam = regression . trend # evaluate geodesic at 100 equidistant points X = gam . eval () To visualize the regressed geodesic, the 100 rotation matrices that were sampled from it as well as the 6 data matrices were applied to the vector \\(q=\\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}^T\\) . The results all lie on the unit sphere; they are shown in the following image. Figure 1 Geodesic regression in SO(3) visualized by applying each matrix to the vector \\(q=\\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}^T\\) . The yellow spheres are the rotations of q by the data points. Applying each of the 100 samples of the optimal geodesic yields the colored curve (color indicating parametrization).","title":"Geodesic regression"},{"location":"tutorial_regression/#higher-order-regression","text":"If the relationship between the observed variable and its co-varying parameter is nonlinear (e.g., when there are saturation effects), then geodesic regression is not adequate. Instead, higher-order models are necessary that generalize polynomial regression. In Morphomatics, manifold-valued B\u00e9zier curves are used for this. Apart from being generalized polynomials, they can be constructed explicitly, which allows for fast computations. After model selection, i.e., choosing a degree \\(k\\) , the least squares estimator within the class of B\u00e9zier curves of degree \\(k\\) is the result of the regression. In the following, we show regression with cubic B\u00e9zier curves for the same data as in the example above. import numpy as np from morphomatics.manifold import SO3 from morphomatics.stats import RiemannianRegression \"\"\"Regression with cubic curves for data in SO(3)\"\"\" M = SO3 () # z-axis is axis of rotation I = np . eye ( 3 ) R = np . array ([[ np . cos ( np . pi / 6 ), - np . sin ( np . pi / 6 ), 0 ], [ np . sin ( np . pi / 6 ), np . cos ( np . pi / 6 ), 0 ], [ 0 , 0 , 1 ]]) Y = np . zeros (( 6 , 1 , 3 , 3 )) Y [ 0 , 0 ] = M . exp ( M . geopoint ( I , R , - 2 / 3 ), np . array ([[ 0 , 0 , 0.1 ], [ 0 , 0 , 0 ], [ - 0.1 , 0 , 0 ]])) Y [ 1 , 0 ] = M . exp ( M . geopoint ( I , R , - 1 / 3 ), np . array ([[ 0 , 0 , 0 ], [ 0 , 0 , 0.2 ], [ 0 , - 0.2 , 0 ]])) Y [ 2 , 0 ] = I Y [ 3 , 0 ] = M . exp ( M . geopoint ( I , R , 1 / 3 ), np . array ([[ 0 , 0 , 0 ], [ 0 , 0 , 0.2 ], [ 0 , - 0.2 , 0 ]])) Y [ 4 , 0 ] = M . exp ( M . geopoint ( I , R , 2 / 3 ), np . array ([[ 0 , 0 , 0.1 ], [ 0 , 0 , 0 ], [ - 0.1 , 0 , 0 ]])) Y [ 5 , 0 ] = R # corresponding time points t = np . array ([ 0 , 1 / 5 , 2 / 5 , 3 / 5 , 4 / 5 , 1 ]) # cubic B\u00e9zier curve have degree 3 degrees = np . array ([ 3 ]) # solve regression = RiemannianRegression ( M , Y , t , degrees ) # cubic least-squares estimator bet = regression . trend # evaluate the curve at 100 equidistant points X = bet . eval () The results can be visulized as for geodesic regression. Note that the cubic curve describes the data a lot better than the geodesic. Figure 2 Regression with cubic B\u00e9zier curves in SO(3) visualized by applying each matrix to the vector \\(q=\\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}^T\\) . The yellow spheres are the rotations of q by the data points. Applying each of the 100 samples of the optimal geodesic yields the colored curve (color indicating parametrization).","title":"Higher-order regression"},{"location":"tutorial_regression/#spline-regression","text":"Generalized B\u00e9zier curves can be joined together in a differentiable way. The resulting B\u00e9zier splines are very flexible and, thus, allow to describe many phenomena. In particular, since there are closed B\u00e9zier splines, they can be used to model cyclic behavior like the motion of the heart. import numpy as np from morphomatics.manifold import SO3 from morphomatics.stats import RiemannianRegression \"\"\"Regression with closed splines for data in SO(3)\"\"\" M = SO3 () # z-axis is axis of rotation I = np . eye ( 3 ) Rz = np . array ([[ np . cos ( np . pi / 6 ), - np . sin ( np . pi / 6 ), 0 ], [ np . sin ( np . pi / 6 ), np . cos ( np . pi / 6 ), 0 ], [ 0 , 0 , 1 ]]) # x-axis is axis of rotation Rx = np . array ([[ 1 , 0 , 0 ], [ 0 , np . cos ( np . pi / 6 ), - np . sin ( np . pi / 6 )], [ 0 , np . sin ( np . pi / 6 ), np . cos ( np . pi / 6 )]]) Y = np . zeros (( 4 , 1 , 3 , 3 )) Y [ 0 , 0 ] = I Y [ 1 , 0 ] = Rz Y [ 2 , 0 ] = Rx @ Rz Y [ 3 , 0 ] = Rx # spline consisting of 2 cubic segments (first and last segment must be at least cubic) degrees = np . array ([ 3 , 3 ]) # time points between 0 and 2 because we have two segments t = np . array ([ 1 / 3 , 2 / 3 , 4 / 3 , 5 / 3 ]) # solve for closed spline regression = RiemannianRegression ( M , Y , t , degrees , iscycle = True ) # least-squares estimator within the class of closed B\u00e9zier splines with two cubic segments bet = regression . trend # evaluate the spline at 100 equidistant points X = bet . eval ( time = np . linspace ( 0 , bet . nsegments , 100 )) Again, the results can be visualized on the sphere. Note that the computed closed spline interpolates the data points in this case. The reason for this is that we have only 4 data points and the same number of degrees of freedom. In general though, regression assumes noisy measurements and, thus, least-squares optimization and not interpolation is the goal. Figure 3 Regression with closed B\u00e9zier splines consisting of 2 cubic segments in SO(3). Results are visualized by applying each matrix to the vector \\(q=\\begin{bmatrix} 1 & 0 & 0 \\end{bmatrix}^T\\) . The yellow spheres are the rotations of q by the data points. Applying each of the 100 samples of the optimal geodesic yields the colored curve (color indicating parametrization).","title":"Spline regression"},{"location":"tutorial_shape_space/","text":"Shape space A key component in the analysis of shape collections is the notion of a shape space, i.e. a space in which every point corresponds to a particular shape. We will follow a deformation-based approach where a common deformable template encodes the typicality of the object class under study. The shape variability in turn is encoded by deformations of the template (referred to as reference shape in the following). Discrete representation To obtain a computational model, we require a digital representation of shapes and variations thereof. To this end, we employ triangular surface meshes for which we provide the Surface class. A surface mesh is specified by a pair of matrices: \\(v = \\begin{bmatrix} x_0 & y_0 & z_0 \\\\ x_1 & y_1 & z_1 \\\\ & \\vdots & \\end{bmatrix} \\in \\mathbb{R}^{n \\times 3} \\text{ and } f = \\begin{bmatrix} i_0 & j_0 & k_0 \\\\ i_1 & j_1 & k_1 \\\\ & \\vdots & \\end{bmatrix} \\in \\mathbb{R}^{m \\times 3},\\) where \\(v\\) holds the coordinates of \\(n\\) vertices and \\(f\\) lists which vertices (i.e. indices thereof w.r.t. \\(v\\) ) form each of \\(m\\) triangles. For example, we can create a tetrahedron like this: import numpy as np from morphomatics.geom import Surface # 4 vertices v = np . array ([ [ 0.57735 , 0.57735 , 0.57735 ], [ - 0.57735 , 0.57735 , - 0.57735 ], [ - 0.57735 , - 0.57735 , 0.57735 ], [ 0.57735 , - 0.57735 , - 0.57735 ] ]) # 4 triangles # note: by sharing vertices (each is referenced 3 times), triangles are 'glued' together f = np . array ([ [ 0 , 3 , 1 ], [ 1 , 3 , 2 ], [ 1 , 2 , 0 ], [ 0 , 2 , 3 ] ]) S = Surface ( v , f ) In order to encode deformations, hence shape variations, we focus on simplicial maps, i.e. deformations that map triangles onto triangles and are entirely determined by the images of the vertices. Given a triangulated reference shape \\((\\bar{v}, \\bar{f})\\) , each surface in a collection can be represented by a mesh with same connectivity \\(f_i \\equiv \\bar{f}\\) and mapped vertices \\(v_i = \\phi_i(\\bar{v})\\) . The task of determining the \\(\\phi_i\\) is known as correspondence problem. There is a multitude of approaches to establish correspondence ranging from fully automatic to expert guided ones. The best choice is typically application dependent and we assume that this step has been carried out during pre-process. Shape distance Codifying shapes as simplicial deformations allows to interpret them as elements in the space of vertex coordinates \\(\\mathbb{R}^{n \\times 3}\\) . This configuration space not only encodes the geometric form of objects but also their scale, position and orientation within the 3D space they are embedded in. We can endow this space with a rich geometric structure by equipping it with a non-trivial metric that quantifies shape (dis)similarity. In particular, for shape spaces we require the metric to be invariant under rotations and translations. We can further adopt a physically-based perspective and design the metric to favor natural deformations promising an improved consistency and compact encoding of constraints. The different approaches available within morphomatics are sub-classes of ShapeSpace (in morphomatics.manifold.ShapeSpae ) that in turn inherits from pymanopt 's class Manifold . The available shape spaces are: Point distribution model (see morphomatics.manifold.PointDistributionModel ) A linearized, i.e. Euclidean, shape space mainly for comparison purposes. Rotational and translational effects are reduced via Procrustes alignment to the reference shape. Differential coordinates model (see morphomatics.manifold.DifferentialCoords ) A Riemannian shape space that is able to account for the nonlinearity in shape variation by employing a differential representation that puts the local geometric variability into focus. The differential coordinates are endowed with a Lie group structure that comes with both: Excellent theoretical properties and closed-form expressions yielding simple and efficient algorithms. While translation invariant, rotational effects are reduced via Procrustes alignment to the reference shape. Fundamental coordinates model (see morphomatics.manifold.FundamentalCoords ) A surface-theoretic approach that is invariant under Euclidean motion and thus alignment-free. The rich structure of the derived shape space assures valid shape instances even in presence of strong nonlinear variability. The representation builds upon metric distortion and curvature of shapes as elements of Lie groups that allow for closed-form evaluation of Riemannian operations. Geodesic calculus Due to the lack of familiar properties such as a vector space structure, calculus in non-Euclidean shape spaces can be computationally challenging. Remarkably, the shape space provided here account for the non-linearity in shapes and at the same time offer fast and numerically robust processing. For example, computing geodesic distances or Riemannian exponential/logarithmic maps does not require iterative approximation schemes. S_1 : Surface S_2 : Surface M : ShapeSpace # TODO: load surfaces, init space # map surfaces to shape space coordinates c_1 = M . to_coords ( S_1 . v ) c_2 = M . to_coords ( S_2 . v ) # perform computations, e.g. ... # ... compute distance M . dist ( c_1 , c_2 ) # ... interpolate surfaces (mid-point on geodesic) diff = M . log ( c_1 , c_2 ) mean = M . exp ( c_1 , 0.5 * diff ) # get vertex coordinates of mean v = M . from_coords ( mean )","title":"Shape Space"},{"location":"tutorial_shape_space/#shape-space","text":"A key component in the analysis of shape collections is the notion of a shape space, i.e. a space in which every point corresponds to a particular shape. We will follow a deformation-based approach where a common deformable template encodes the typicality of the object class under study. The shape variability in turn is encoded by deformations of the template (referred to as reference shape in the following).","title":"Shape space"},{"location":"tutorial_shape_space/#discrete-representation","text":"To obtain a computational model, we require a digital representation of shapes and variations thereof. To this end, we employ triangular surface meshes for which we provide the Surface class. A surface mesh is specified by a pair of matrices: \\(v = \\begin{bmatrix} x_0 & y_0 & z_0 \\\\ x_1 & y_1 & z_1 \\\\ & \\vdots & \\end{bmatrix} \\in \\mathbb{R}^{n \\times 3} \\text{ and } f = \\begin{bmatrix} i_0 & j_0 & k_0 \\\\ i_1 & j_1 & k_1 \\\\ & \\vdots & \\end{bmatrix} \\in \\mathbb{R}^{m \\times 3},\\) where \\(v\\) holds the coordinates of \\(n\\) vertices and \\(f\\) lists which vertices (i.e. indices thereof w.r.t. \\(v\\) ) form each of \\(m\\) triangles. For example, we can create a tetrahedron like this: import numpy as np from morphomatics.geom import Surface # 4 vertices v = np . array ([ [ 0.57735 , 0.57735 , 0.57735 ], [ - 0.57735 , 0.57735 , - 0.57735 ], [ - 0.57735 , - 0.57735 , 0.57735 ], [ 0.57735 , - 0.57735 , - 0.57735 ] ]) # 4 triangles # note: by sharing vertices (each is referenced 3 times), triangles are 'glued' together f = np . array ([ [ 0 , 3 , 1 ], [ 1 , 3 , 2 ], [ 1 , 2 , 0 ], [ 0 , 2 , 3 ] ]) S = Surface ( v , f ) In order to encode deformations, hence shape variations, we focus on simplicial maps, i.e. deformations that map triangles onto triangles and are entirely determined by the images of the vertices. Given a triangulated reference shape \\((\\bar{v}, \\bar{f})\\) , each surface in a collection can be represented by a mesh with same connectivity \\(f_i \\equiv \\bar{f}\\) and mapped vertices \\(v_i = \\phi_i(\\bar{v})\\) . The task of determining the \\(\\phi_i\\) is known as correspondence problem. There is a multitude of approaches to establish correspondence ranging from fully automatic to expert guided ones. The best choice is typically application dependent and we assume that this step has been carried out during pre-process.","title":"Discrete representation"},{"location":"tutorial_shape_space/#shape-distance","text":"Codifying shapes as simplicial deformations allows to interpret them as elements in the space of vertex coordinates \\(\\mathbb{R}^{n \\times 3}\\) . This configuration space not only encodes the geometric form of objects but also their scale, position and orientation within the 3D space they are embedded in. We can endow this space with a rich geometric structure by equipping it with a non-trivial metric that quantifies shape (dis)similarity. In particular, for shape spaces we require the metric to be invariant under rotations and translations. We can further adopt a physically-based perspective and design the metric to favor natural deformations promising an improved consistency and compact encoding of constraints. The different approaches available within morphomatics are sub-classes of ShapeSpace (in morphomatics.manifold.ShapeSpae ) that in turn inherits from pymanopt 's class Manifold . The available shape spaces are: Point distribution model (see morphomatics.manifold.PointDistributionModel ) A linearized, i.e. Euclidean, shape space mainly for comparison purposes. Rotational and translational effects are reduced via Procrustes alignment to the reference shape. Differential coordinates model (see morphomatics.manifold.DifferentialCoords ) A Riemannian shape space that is able to account for the nonlinearity in shape variation by employing a differential representation that puts the local geometric variability into focus. The differential coordinates are endowed with a Lie group structure that comes with both: Excellent theoretical properties and closed-form expressions yielding simple and efficient algorithms. While translation invariant, rotational effects are reduced via Procrustes alignment to the reference shape. Fundamental coordinates model (see morphomatics.manifold.FundamentalCoords ) A surface-theoretic approach that is invariant under Euclidean motion and thus alignment-free. The rich structure of the derived shape space assures valid shape instances even in presence of strong nonlinear variability. The representation builds upon metric distortion and curvature of shapes as elements of Lie groups that allow for closed-form evaluation of Riemannian operations.","title":"Shape distance"},{"location":"tutorial_shape_space/#geodesic-calculus","text":"Due to the lack of familiar properties such as a vector space structure, calculus in non-Euclidean shape spaces can be computationally challenging. Remarkably, the shape space provided here account for the non-linearity in shapes and at the same time offer fast and numerically robust processing. For example, computing geodesic distances or Riemannian exponential/logarithmic maps does not require iterative approximation schemes. S_1 : Surface S_2 : Surface M : ShapeSpace # TODO: load surfaces, init space # map surfaces to shape space coordinates c_1 = M . to_coords ( S_1 . v ) c_2 = M . to_coords ( S_2 . v ) # perform computations, e.g. ... # ... compute distance M . dist ( c_1 , c_2 ) # ... interpolate surfaces (mid-point on geodesic) diff = M . log ( c_1 , c_2 ) mean = M . exp ( c_1 , 0.5 * diff ) # get vertex coordinates of mean v = M . from_coords ( mean )","title":"Geodesic calculus"},{"location":"tutorial_ssm/","text":"Statistical shape modeling Statistical shape models (SSMs) provide a principled way for extracting knowledge from empirically given collections of objects. Instead of considering only a few quantities derived from a shape, such as volume, studying shapes in their entirety allows for a full geometric characterization and hence more differentiated assertions about the shapes. SSMs describe the geometric variability in a collection in terms of a mean shape and a hierarchy of major modes explaining the main trends of shape variation. Based on a notion of shape space, SSMs can be learned from consistently parametrized instances from the object class under study. The resulting models provide a shape prior that can be used to constrain synthesis and analysis problems. Moreover, their parameter space provides a compact representation that is amenable to learning algorithms (e.g. classification or clustering), evaluation, and exploration. Intrinsic mean The simplest - yet also perhaps most fundamentally important - statistic is the sample mean, which estimates the center of a data set. Because a Riemannian manifold \\(\\mathcal{M}\\) has a distance metric \\(\\text{dist}_\\mathcal{M}\\) , we can characterize the mean as the point closest to the data points \\(x_1,\\ldots,x_N \\in \\mathcal{M}\\) . This leads to the notion of (sample) Fr\u00e9chet mean that is the minimizer of the sum-of-squared geodesic distances to the data: \\[\\mu = \\arg\\min_{x\\in\\mathcal{M}} \\sum_{i=1}^N \\text{dist}_\\mathcal{M}^2(x,x_i)\\] While closed-form solutions exist in flat spaces, solving this least-squares problem in general requires iterative optimization routines. To this end, morphomatics.stats.ExponentialBarycenter implements the efficient Newton-type fixed-point iteration \\[ \\mu_{k+i} = \\exp_{\\mu_k} \\left( 1/N \\sum_{i=1}^N \\log_{\\mu_k}(x_i) \\right). \\] As it requires only a notion of exponential and logarithmic map, it can also be used to compute bi-invariant means in affine connection spaces. Principal geodesic analysis For second order statistics morphomatics.stats.PrincipalGeodesicAnalysis provides (linearized) Principal Geodesic Analysis at \\(\\mu\\) that is an extension of the common Principal Component Analysis to Riemannian manifolds allowing for covariance analysis. In particular, the solution is found algorithmically by eigendecomposition of the Gram matrix \\(C=(c_{ij})_{ij}\\) , with elements \\(c_{ij}=g_{\\mu}{\\left(\\log_\\mu{(x_i)}, \\log_\\mu{(x_j)}\\right)}\\) . Statistical shape model (SSM) In order to avoid a systematic bias due to the choice of reference shape (cf. the introduction to Shape Space ), we require it to agree with the mean of the training data. This approach yields a cyclic dependency between the reference and the mean shape. In morphomatics.stats.StatisticalShapeModel we provide an method to construct a statistical shape model for which the mean agrees with the reference based on an alternating optimization strategy. Currently SSMs can be build based on three different Shape Spaces : PointDistributionModel , DifferentialCoords and FundamentalCoords . The illustrative example below details how to set up a morphomatics.manifold.FundamentalCoords SSM and explains its basic usage. Other types are constructed analogously replacing the Shape Space accordingly. However, as Shape Spaces can allow for parameters the following code snippet is showing the default case. Note that faces and vertices need to be organized as explained here . import os import numpy as np from morphomatics.geom import Surface from morphomatics.stats import StatisticalShapeModel from morphomatics.manifold import FundamentalCoords # load surfaces f = np . load ( 'shape_faces.npy' ) vertFiles = [ 'shape_A_verts.npy' , 'shape_B_verts.npy' ] surfaces = [ Surface ( np . load ( vf ), f ) for vf in vertFiles ] # construct model SSM = StatisticalShapeModel ( lambda ref : FundamentalCoords ( ref )) SSM . construct ( surfaces ) Having set up the model one can easily access the mean shape vertex coordinates, as well as the mean coordinates in Shape Space: # export mean shape vertex coords np . save ( 'mean_verts.npy' , SSM . mean . v ) # export mean shape coords in shape space np . save ( 'mean_coords.npy' , SSM . mean_coords ) Figure 1 Visualization of Input shapes (yellow) and fundamental coordinate mean (blue) for an example geometry consisting of a straight bar and a helix structure. Basic SSM-properties, its modes of variation, its per-mode-variances and its shape coefficients (uniquely determining all input shapes), can be accessed directly: # export shape modes of variation np . save ( 'shape_modes.npy' , SSM . modes ) # export mode variances np . save ( 'mode_variances.npy' , SSM . variances ) # export shape coefficients / shape weights np . save ( 'shape_coefficients.npy' , SSM . coeffs ) Making straightforward use of the above one can generate samples from the SSM along the first mode of variation employing the exponential map of the underlying Shape Space: # sample trajectory along the main mode of variation and export vertex coords std = np . sqrt ( SSM . variances [ 0 ]) for t in np . linspace ( - 1.0 , 1.0 , 11 ): v = SSM . space . from_coords ( SSM . space . exp ( SSM . mean_coords , t * std * SSM . modes [ 0 ])) np . save ( 'main_mode_at_t_' + ' {:.1f} ' . format ( t ) + '_verts.npy' , v ) Figure 2 Main mode of variation interpolating between straight bar and helix structure.","title":"Statistical Shape Modeling"},{"location":"tutorial_ssm/#statistical-shape-modeling","text":"Statistical shape models (SSMs) provide a principled way for extracting knowledge from empirically given collections of objects. Instead of considering only a few quantities derived from a shape, such as volume, studying shapes in their entirety allows for a full geometric characterization and hence more differentiated assertions about the shapes. SSMs describe the geometric variability in a collection in terms of a mean shape and a hierarchy of major modes explaining the main trends of shape variation. Based on a notion of shape space, SSMs can be learned from consistently parametrized instances from the object class under study. The resulting models provide a shape prior that can be used to constrain synthesis and analysis problems. Moreover, their parameter space provides a compact representation that is amenable to learning algorithms (e.g. classification or clustering), evaluation, and exploration.","title":"Statistical shape modeling"},{"location":"tutorial_ssm/#intrinsic-mean","text":"The simplest - yet also perhaps most fundamentally important - statistic is the sample mean, which estimates the center of a data set. Because a Riemannian manifold \\(\\mathcal{M}\\) has a distance metric \\(\\text{dist}_\\mathcal{M}\\) , we can characterize the mean as the point closest to the data points \\(x_1,\\ldots,x_N \\in \\mathcal{M}\\) . This leads to the notion of (sample) Fr\u00e9chet mean that is the minimizer of the sum-of-squared geodesic distances to the data: \\[\\mu = \\arg\\min_{x\\in\\mathcal{M}} \\sum_{i=1}^N \\text{dist}_\\mathcal{M}^2(x,x_i)\\] While closed-form solutions exist in flat spaces, solving this least-squares problem in general requires iterative optimization routines. To this end, morphomatics.stats.ExponentialBarycenter implements the efficient Newton-type fixed-point iteration \\[ \\mu_{k+i} = \\exp_{\\mu_k} \\left( 1/N \\sum_{i=1}^N \\log_{\\mu_k}(x_i) \\right). \\] As it requires only a notion of exponential and logarithmic map, it can also be used to compute bi-invariant means in affine connection spaces.","title":"Intrinsic mean"},{"location":"tutorial_ssm/#principal-geodesic-analysis","text":"For second order statistics morphomatics.stats.PrincipalGeodesicAnalysis provides (linearized) Principal Geodesic Analysis at \\(\\mu\\) that is an extension of the common Principal Component Analysis to Riemannian manifolds allowing for covariance analysis. In particular, the solution is found algorithmically by eigendecomposition of the Gram matrix \\(C=(c_{ij})_{ij}\\) , with elements \\(c_{ij}=g_{\\mu}{\\left(\\log_\\mu{(x_i)}, \\log_\\mu{(x_j)}\\right)}\\) .","title":"Principal geodesic analysis"},{"location":"tutorial_ssm/#statistical-shape-model-ssm","text":"In order to avoid a systematic bias due to the choice of reference shape (cf. the introduction to Shape Space ), we require it to agree with the mean of the training data. This approach yields a cyclic dependency between the reference and the mean shape. In morphomatics.stats.StatisticalShapeModel we provide an method to construct a statistical shape model for which the mean agrees with the reference based on an alternating optimization strategy. Currently SSMs can be build based on three different Shape Spaces : PointDistributionModel , DifferentialCoords and FundamentalCoords . The illustrative example below details how to set up a morphomatics.manifold.FundamentalCoords SSM and explains its basic usage. Other types are constructed analogously replacing the Shape Space accordingly. However, as Shape Spaces can allow for parameters the following code snippet is showing the default case. Note that faces and vertices need to be organized as explained here . import os import numpy as np from morphomatics.geom import Surface from morphomatics.stats import StatisticalShapeModel from morphomatics.manifold import FundamentalCoords # load surfaces f = np . load ( 'shape_faces.npy' ) vertFiles = [ 'shape_A_verts.npy' , 'shape_B_verts.npy' ] surfaces = [ Surface ( np . load ( vf ), f ) for vf in vertFiles ] # construct model SSM = StatisticalShapeModel ( lambda ref : FundamentalCoords ( ref )) SSM . construct ( surfaces ) Having set up the model one can easily access the mean shape vertex coordinates, as well as the mean coordinates in Shape Space: # export mean shape vertex coords np . save ( 'mean_verts.npy' , SSM . mean . v ) # export mean shape coords in shape space np . save ( 'mean_coords.npy' , SSM . mean_coords ) Figure 1 Visualization of Input shapes (yellow) and fundamental coordinate mean (blue) for an example geometry consisting of a straight bar and a helix structure. Basic SSM-properties, its modes of variation, its per-mode-variances and its shape coefficients (uniquely determining all input shapes), can be accessed directly: # export shape modes of variation np . save ( 'shape_modes.npy' , SSM . modes ) # export mode variances np . save ( 'mode_variances.npy' , SSM . variances ) # export shape coefficients / shape weights np . save ( 'shape_coefficients.npy' , SSM . coeffs ) Making straightforward use of the above one can generate samples from the SSM along the first mode of variation employing the exponential map of the underlying Shape Space: # sample trajectory along the main mode of variation and export vertex coords std = np . sqrt ( SSM . variances [ 0 ]) for t in np . linspace ( - 1.0 , 1.0 , 11 ): v = SSM . space . from_coords ( SSM . space . exp ( SSM . mean_coords , t * std * SSM . modes [ 0 ])) np . save ( 'main_mode_at_t_' + ' {:.1f} ' . format ( t ) + '_verts.npy' , v ) Figure 2 Main mode of variation interpolating between straight bar and helix structure.","title":"Statistical shape model (SSM)"}]}